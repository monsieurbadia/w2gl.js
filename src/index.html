<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>w2gl</title>
    <style>
      body {
        margin: 0;
        background: #ffffff;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="./index.js"></script>
    <script>
      
      // console.log( W2GL ); // { default: { init: f}, __esModule: true }

      document.addEventListener( 'DOMContentLoaded', _ => {

        // W2GL test implementation

        W2GL.W2GL.init( {

          scene: {
            scene1: {}
          },
          camera: {
            camera1: {
              size: [ window.innerWidth, window.innerHeight ],
              type: 'perspective'
            }
          },
          mesh: {
            plane: {
              geometry: {
                buffer: true,
                options: [ 2, 2 ],
                specific: 'plane'
              },
              material: {
                options: {
                  transparent: true
                },
                specific: 'normal'
              },
              shader: {
                vertex: `

                  #include <core_vertex>
                  
                  uniform vec2 resolution;

                  varying vec2 vUv;

                  void main () {

                    vec2 _position = vec2( position.xy );

                    vUv = uv;
                    vUv = position.xy;
                    vUv.x *= resolution.x / resolution.y; // normalise screen ratio

                    gl_Position = vec4( position.xy, 0.0, 1.0 );
                  }
 
                `,
                fragment: `

                  #include <core_fragment>
                  #include <core_color>

                  uniform vec2 resolution;
                  uniform float time;

                  varying vec2 vUv;

                  float map(vec3 pos) {

                    float planeDist = plane( pos );

                    pos.xy = rotate( pos.xy, pos.z * sin( time ) * 0.01 );

                    pos.x = abs( pos.x );

                    pos = mod( pos + 10.0, 20.0 ) - 10.0;

                    // pos.xy = rotate( pos.xy, time );
                    pos.xz = rotate( pos.xz, time * 0.7 );

                    return min( planeDist, sphere( vec3(pos.x, abs(pos.y - 4.0), pos.z ), 4.0 ) );

                  }

                  vec3 material(vec3 pos) {
                    
                    return vec3(smoothstep(0.4, 0.41, fract(pos.x + sin(pos.z * 0.4 + time))));

                  }

                  vec3 albedo( vec3 pos ) {
 
                    pos += 0.5;

                    // return vec3(fract(pos.x) * fract(pos.z)) * vec3(1.0);
                    float f = smoothstep(0.27, 0.3, fract(pos.x + sin(pos.z) * 0.4));

                    return f * vec3( 1.0 );

                  }

                  void main () {

                    vec3 pos = vec3( 0.0, 5.0 + sin( time * 0.2 ) * 2.0, -10.0 );
                    vec3 dir = normalize(vec3(vUv, 1.0));
                    
                    // vec3 color = mix(vec3(0.4, 0.5, 0.6), vec3(0.7, 0.8, 0.9), -vUv.y);

                    vec3 color = BLACK;

                    for ( int i = 0; i < 64; i++ ) {
                        
                      float d = map( pos );

                      if ( d < 0.01 ) {

                        float lighDistance = sphere( pos, 1.0 );

                        color = 30.0 / ( lighDistance * lighDistance ) * vec3( 0.0, 0.0, 1.0 ) * albedo( pos );

                        break;

                      }
                      
                      pos += d * dir;

                    }
                    
                    gl_FragColor = vec4( color, 1.0 );

                  }

                `
              }
            }
          },
          renderer: {
            renderer1: {
              options: {
                antialias: true,
                pixelRatio: window.devicePixelRatio,
                size: [ window.innerWidth, window.innerHeight ],
              }
            }
          }

        }, ( starter ) => {

          console.log( starter );

          /* INIT WEBGL */

          // 1. init scene
          starter.scene.scene1.init( [ starter.mesh.plane ] );

          // 2. init camera
          starter.camera.camera1.init(  );

          // 3. init renderer
          starter.renderer.renderer1.init( starter.scene.scene1, starter.camera.camera1 );

          /* INIT LISTENERS */

          // 4. onresize: reset screen (optional)
          starter.event.onresize( starter.screen.resize );

          // 5. onmousemove: set coordinates (optional)
          // starter.event.onmousemove( starter.mouse.mousemove );

          /* THEN USE LISTENERS TO UPDATE THINGS */

          // onrender: update mesh
          starter.mesh.plane.onrender( timer => {

            starter.mesh.plane.material.uniforms.time.value = timer.time;

          } );

          // onresize: refresh renderer size
          starter.renderer.renderer1.onresize( event => {

            starter.renderer.renderer1.setSize( starter.screen.width, starter.screen.height );

          } );

          // onmousemove: set mouse coordinates values
          starter.mesh.plane.onmousemove( event => {

            starter.mesh.plane.material.uniforms.mouse.value.x = starter.mouse.x;
            starter.mesh.plane.material.uniforms.mouse.value.y = starter.mouse.y;

          } );

          // onresize: update resolution coordinates values
          starter.mesh.plane.onresize( event => {

            starter.mesh.plane.material.uniforms.resolution.value.x = starter.screen.width;
            starter.mesh.plane.material.uniforms.resolution.value.y = starter.screen.height;

          } );

        } );

      }, false );

    </script>
  </body>
</html>